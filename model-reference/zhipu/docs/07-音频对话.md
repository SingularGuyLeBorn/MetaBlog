# 音频对话（Audio Chat）

## 功能介绍

音频对话（Audio Chat）支持语音输入和输出，实现语音交互功能。GLM-4-Voice 是智谱 AI 推出的端到端语音模型，具备以下核心能力：

### 1. 语音理解
- 理解语音内容并提取语义信息
- 支持自然语言理解和意图识别
- 可进行多轮语音对话

### 2. 语音生成
- 将文本转换为自然语音输出
- 支持流式音频生成
- 生成音频为 base64 编码的 WAV 格式

### 3. 语音识别
- 将语音转换为文字（语音转文字）
- 支持中文、英文等多种语言识别
- 实时识别和批量识别

## 适用场景

| 场景 | 说明 |
|:---|:---|
| 语音助手 | 构建智能语音对话系统，支持自然语音交互 |
| 语音转文字 | 会议记录、语音笔记、字幕生成等 |
| 文字转语音 | 有声读物、语音播报、辅助阅读等 |
| 多模态交互 | 结合视觉和语音的综合交互应用 |
| 客服系统 | 智能语音客服和自动应答系统 |

## 支持的模型

| 模型 | 模型代码 | 上下文 | 最大输出 | 思考模式 | 思维链支持 | 音频支持 |
|:---|:---|:---:|:---:|:---:|:---:|:---|
| GLM-4-Voice | glm-4-voice | 8K | 4K | ❌ 不支持 | ❌ 不支持 | 语音理解+生成 |

**GLM-4-Voice 特点：**
- 专门的语音模型，不支持思考模式
- 不支持 `thinking` 参数
- 不返回 `reasoning_content`
- 专注于语音理解和生成任务

## 音频格式和限制

### 音频输入要求
- **格式**: WAV 或 MP3
- **编码方式**: Base64
- **最大时长**: 10 分钟
- **Token 计算**: 1秒音频 ≈ 12.5 Tokens
- **采样率**: 建议 16kHz 或 24kHz

### 音频输出说明
- **格式**: WAV (PCM 16-bit)
- **编码**: Base64
- **采样率**: 24kHz

### Token 消耗示例
| 音频时长 | 估算 Tokens |
|:---|:---:|
| 1 秒 | ~12.5 |
| 10 秒 | ~125 |
| 1 分钟 | ~750 |
| 10 分钟 | ~7500 |

## API 调用方式

### 端点信息
```
POST https://open.bigmodel.cn/api/paas/v4/chat/completions
```

### 请求头
```json
{
  "Authorization": "Bearer YOUR_API_KEY",
  "Content-Type": "application/json"
}
```

### 音频输入格式

使用 `input_audio` 类型传递音频数据：

```json
{
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "input_audio",
          "input_audio": {
            "data": "base64_encoded_audio_data",
            "format": "wav"
          }
        }
      ]
    }
  ]
}
```

### 请求参数说明

| 参数 | 类型 | 必填 | 说明 |
|:---|:---|:---:|:---|
| model | string | 是 | 模型代码，如 `glm-4-voice` |
| messages | array | 是 | 对话消息列表 |
| stream | boolean | 否 | 是否流式返回，默认为 false |
| temperature | number | 否 | 采样温度，范围 0-1 |
| max_tokens | integer | 否 | 最大输出 token 数 |

### 响应中的音频数据

当模型生成语音回复时，响应中包含音频数据：

```json
{
  "choices": [
    {
      "message": {
        "role": "assistant",
        "content": [
          {
            "type": "text",
            "text": "这是文本回复内容"
          },
          {
            "type": "audio",
            "audio": {
              "data": "base64_encoded_audio_data",
              "format": "wav"
            }
          }
        ]
      }
    }
  ]
}
```

## 代码示例

### Python 示例 - 语音对话

```python
import requests
import base64

# API 配置
API_KEY = "YOUR_API_KEY"
API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions"

# 读取音频文件并编码为 base64
def encode_audio(file_path):
    with open(file_path, "rb") as audio_file:
        return base64.b64encode(audio_file.read()).decode('utf-8')

# 保存返回的音频数据
def save_audio(base64_data, output_path):
    audio_data = base64.b64decode(base64_data)
    with open(output_path, "wb") as f:
        f.write(audio_data)
    print(f"音频已保存到: {output_path}")

# 发送语音消息
def audio_chat(audio_base64, audio_format="wav"):
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": "glm-4-voice",
        "messages": [
            {
                "role": "user",
                "content": [
                    {
                        "type": "input_audio",
                        "input_audio": {
                            "data": audio_base64,
                            "format": audio_format
                        }
                    }
                ]
            }
        ]
    }
    
    response = requests.post(API_URL, headers=headers, json=payload)
    return response.json()

# 使用示例
# 1. 编码本地音频文件
audio_base64 = encode_audio("input.wav")

# 2. 发送语音对话请求
result = audio_chat(audio_base64)

# 3. 解析响应并保存音频（如果有）
if "choices" in result:
    content = result["choices"][0]["message"]["content"]
    for item in content:
        if item["type"] == "text":
            print(f"文本回复: {item['text']}")
        elif item["type"] == "audio":
            save_audio(item["audio"]["data"], "output.wav")
```

### Python 示例 - 多轮语音对话

```python
import requests
import base64

API_KEY = "YOUR_API_KEY"
API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions"

def encode_audio(file_path):
    with open(file_path, "rb") as f:
        return base64.b64encode(f.read()).decode('utf-8')

def save_audio(base64_data, output_path):
    with open(output_path, "wb") as f:
        f.write(base64.b64decode(base64_data))

def audio_chat_with_history(messages):
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": "glm-4-voice",
        "messages": messages
    }
    
    response = requests.post(API_URL, headers=headers, json=payload)
    return response.json()

# 多轮对话示例
messages = []

# 第一轮：用户发送语音
audio_base64 = encode_audio("question1.wav")
messages.append({
    "role": "user",
    "content": [
        {
            "type": "input_audio",
            "input_audio": {
                "data": audio_base64,
                "format": "wav"
            }
        }
    ]
})

result1 = audio_chat_with_history(messages)
# 解析响应并添加到历史
assistant_content = result1["choices"][0]["message"]["content"]
messages.append({
    "role": "assistant",
    "content": assistant_content
})

# 第二轮：用户继续发送语音
audio_base64_2 = encode_audio("question2.wav")
messages.append({
    "role": "user",
    "content": [
        {
            "type": "input_audio",
            "input_audio": {
                "data": audio_base64_2,
                "format": "wav"
            }
        }
    ]
})

result2 = audio_chat_with_history(messages)
```

### Python 示例 - 纯文本对话（GLM-4-Voice 也支持文本输入）

```python
import requests

API_KEY = "YOUR_API_KEY"
API_URL = "https://open.bigmodel.cn/api/paas/v4/chat/completions"

def text_chat(message):
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }
    
    payload = {
        "model": "glm-4-voice",
        "messages": [
            {"role": "user", "content": message}
        ]
    }
    
    response = requests.post(API_URL, headers=headers, json=payload)
    return response.json()

# 发送文本消息，获取语音回复
result = text_chat("你好，请介绍一下你自己")
```

## 注意事项

### 1. 音频文件处理
- 确保音频文件格式为 WAV 或 MP3
- 音频文件需要先转换为 base64 编码才能通过 API 发送
- 返回的音频数据也是 base64 编码，需要解码后保存

### 2. Token 限制
- 音频消耗 Token 较多，注意控制音频时长
- 1秒音频约消耗 12.5 Tokens
- 建议将音频控制在合理范围内以节约成本

### 3. 网络稳定性
- 音频数据传输量较大，确保网络连接稳定
- 大音频文件传输可能需要较长时间

### 4. 音质要求
- 输入音频建议使用清晰的人声录音
- 背景噪音可能影响识别准确性
- 建议使用采样率 16kHz 或以上的音频

### 5. 安全提示
- **切勿在客户端暴露 API Key**
- 建议在服务器端处理音频文件的 base64 编解码
- 注意保护用户隐私音频数据

### 6. 错误处理
常见的错误情况及处理建议：

| 错误码 | 说明 | 解决方案 |
|:---|:---|:---|
| 400 | 请求格式错误 | 检查音频 base64 编码是否正确 |
| 413 | 音频文件过大 | 压缩音频或缩短时长 |
| 429 | 请求过于频繁 | 降低请求频率 |
| 500 | 服务器错误 | 稍后重试 |

### 7. 获取 base64 编码的方法

**使用 Python：**
```python
import base64

# 编码音频文件为 base64
with open("audio.wav", "rb") as f:
    base64_data = base64.b64encode(f.read()).decode('utf-8')
    print(base64_data)
```

**使用命令行 (Linux/Mac)：**
```bash
base64 audio.wav > audio.txt
```

**使用命令行 (Windows PowerShell)：**
```powershell
[Convert]::ToBase64String([IO.File]::ReadAllBytes("audio.wav")) | Out-File -Encoding utf8 audio.txt
```

### 8. 保存返回的音频数据

**Python：**
```python
import base64

# 解码 base64 并保存为音频文件
base64_data = "返回的base64数据"
audio_bytes = base64.b64decode(base64_data)
with open("output.wav", "wb") as f:
    f.write(audio_bytes)
```
